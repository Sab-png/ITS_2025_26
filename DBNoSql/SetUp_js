// setup.js - Script per inizializzare il database MongoDB della biblioteca
const { MongoClient, ObjectId } = require('mongodb');
const fs = require('fs').promises;
const path = require('path');

// Configurazione database
const config = {
  url: 'mongodb://admin:password123@localhost:27017',
  dbName: 'library_db',
  options: {
    maxPoolSize: 10,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
  }
};

class LibraryDatabaseSetup {
  constructor() {
    this.client = null;
    this.db = null;
  }

  async connect() {
    try {
      console.log('üîå Connessione a MongoDB...');
      this.client = new MongoClient(config.url, config.options);
      await this.client.connect();
      this.db = this.client.db(config.dbName);
      console.log(' Connessione stabilita con successo');
    } catch (error) {
      console.error(' Errore di connessione:', error.message);
      throw error;
    }
  }

  async disconnect() {
    if (this.client) {
      await this.client.close();
      console.log('üîå Connessione chiusa');
    }
  }

  async createCollections() {
    console.log(' Creazione collezioni...');
    
    const collections = [
      'books',
      'users', 
      'loans',
      'reservations',
      'fines',
      'staff',
      'categories',
      'events'
    ];

    for (const collectionName of collections) {
      try {
        await this.db.createCollection(collectionName);
        console.log(` Collezione '${collectionName}' creata`);
      } catch (error) {
        if (error.code === 48) {
          console.log(`  Collezione '${collectionName}' gi√† esistente`);
        } else {
          throw error;
        }
      }
    }
  }

  async createIndexes() {
    console.log('  Creazione indici...');

    const indexes = [
      // Indici per books
      {
        collection: 'books',
        indexes: [
          { key: { isbn: 1 }, options: { unique: true } },
          { key: { title: 'text', 'authors.name': 'text' }, options: { name: 'search_text' } },
          { key: { genres: 1 } },
          { key: { 'copies.status': 1 } },
          { key: { 'location.section': 1 } }
        ]
      },
      // Indici per users
      {
        collection: 'users',
        indexes: [
          { key: { user_id: 1 }, options: { unique: true } },
          { key: { 'membership.card_number': 1 }, options: { unique: true } },
          { key: { 'personal_info.email': 1 }, options: { unique: true } },
          { key: { 'membership.status': 1 } }
        ]
      },
      // Indici per loans
      {
        collection: 'loans',
        indexes: [
          { key: { loan_id: 1 }, options: { unique: true } },
          { key: { user_id: 1 } },
          { key: { 'book_info.book_id': 1 } },
          { key: { status: 1 } },
          { key: { 'dates.due_date': 1 } },
          { key: { user_id: 1, status: 1 } },
          { key: { status: 1, 'dates.due_date': 1 } }
        ]
      },
      // Indici per reservations
      {
        collection: 'reservations',
        indexes: [
          { key: { user_id: 1, book_id: 1 } },
          { key: { book_id: 1, status: 1, priority: 1 } },
          { key: { status: 1, expiry_date: 1 } }
        ]
      },
      // Indici per fines
      {
        collection: 'fines',
        indexes: [
          { key: { user_id: 1 } },
          { key: { loan_id: 1 } },
          { key: { status: 1 } },
          { key: { issue_date: 1 } }
        ]
      },
      // Indici per staff
      {
        collection: 'staff',
        indexes: [
          { key: { staff_id: 1 }, options: { unique: true } },
          { key: { 'personal_info.email': 1 }, options: { unique: true } },
          { key: { role: 1 } },
          { key: { status: 1 } }
        ]
      }
    ];

    for (const { collection, indexes: collectionIndexes } of indexes) {
      console.log(`  Creando indici per '${collection}'...`);
      
      for (const { key, options = {} } of collectionIndexes) {
        try {
          await this.db.collection(collection).createIndex(key, options);
          console.log(`   Indice creato: ${JSON.stringify(key)}`);
        } catch (error) {
          if (error.code === 85) {
            console.log(`   Indice gi√† esistente: ${JSON.stringify(key)}`);
          } else {
            console.error(`   Errore creando indice ${JSON.stringify(key)}:`, error.message);
          }
        }
      }
    }
  }

  async loadSampleData() {
    console.log(' Caricamento dati di esempio...');

    try {
      // Carica il file JSON con i dati di esempio
      const sampleDataPath = path.join(__dirname, 'data', 'sample-data.json');
      const sampleDataRaw = await fs.readFile(sampleDataPath, 'utf8');
      const sampleData = JSON.parse(sampleDataRaw);

      // Mapping per sostituire i placeholder ObjectId con ObjectId reali
      const bookIdMapping = {};
      
      // Inserisci libri e crea mapping degli ID
      if (sampleData.books && sampleData.books.length > 0) {
        const booksWithObjectIds = sampleData.books.map((book, index) => {
          const bookId = new ObjectId();
          bookIdMapping[`ObjectId_placeholder_${index + 1}`] = bookId;
          
          return {
            ...book,
            _id: bookId,
            // Converti le date da string a Date objects
            'copies': book.copies.map(copy => ({
              ...copy,
              acquisition_date: new Date(copy.acquisition_date)
            })),
            'metadata.created_at': new Date(book.metadata.created_at),
            'metadata.updated_at': new Date(book.metadata.updated_at)
          };
        });

        await this.db.collection('books').insertMany(booksWithObjectIds);
        console.log(` Inseriti ${booksWithObjectIds.length} libri`);
      }

      // Inserisci utenti
      if (sampleData.users && sampleData.users.length > 0) {
        const usersWithDates = sampleData.users.map(user => ({
          ...user,
          'personal_info.date_of_birth': new Date(user.personal_info.date_of_birth),
          'membership.registration_date': new Date(user.membership.registration_date),
          'membership.expiry_date': new Date(user.membership.expiry_date),
          'metadata.created_at': new Date(user.metadata.created_at),
          'metadata.updated_at': new Date(user.metadata.updated_at),
          'metadata.last_login': new Date(user.metadata.last_login)
        }));

        await this.db.collection('users').insertMany(usersWithDates);
        console.log(` Inseriti ${usersWithDates.length} utenti`);
      }

      // Inserisci prestiti con ObjectId corretti
      if (sampleData.loans && sampleData.loans.length > 0) {
        const loansWithObjectIds = sampleData.loans.map(loan => ({
          ...loan,
          'book_info.book_id': bookIdMapping[loan.book_info.book_id] || new ObjectId(),
          'dates.loan_date': new Date(loan.dates.loan_date),
          'dates.due_date': new Date(loan.dates.due_date),
          'dates.return_date': loan.dates.return_date ? new Date(loan.dates.return_date) : null,
          'dates.last_renewal': loan.dates.last_renewal ? new Date(loan.dates.last_renewal) : null,
          'metadata.created_at': new Date(loan.metadata.created_at),
          'metadata.updated_at': new Date(loan.metadata.updated_at)
        }));

        await this.db.collection('loans').insertMany(loansWithObjectIds);
        console.log(` Inseriti ${loansWithObjectIds.length} prestiti`);
      }

      // Inserisci prenotazioni
      if (sampleData.reservations && sampleData.reservations.length > 0) {
        const reservationsWithObjectIds = sampleData.reservations.map(reservation => ({
          ...reservation,
          book_id: bookIdMapping[reservation.book_id] || new ObjectId(),
          reservation_date: new Date(reservation.reservation_date),
          expiry_date: new Date(reservation.expiry_date),
          'metadata.created_at': new Date(reservation.metadata.created_at),
          'metadata.updated_at': new Date(reservation.metadata.updated_at)
        }));

        await this.db.collection('reservations').insertMany(reservationsWithObjectIds);
        console.log(` Inserite ${reservationsWithObjectIds.length} prenotazioni`);
      }

      // Inserisci multe
      if (sampleData.fines && sampleData.fines.length > 0) {
        const finesWithDates = sampleData.fines.map(fine => ({
          ...fine,
          issue_date: new Date(fine.issue_date),
          payment_date: fine.payment_date ? new Date(fine.payment_date) : null,
          'metadata.created_at': new Date(fine.metadata.created_at),
          'metadata.updated_at': new Date(fine.metadata.updated_at)
        }));

        await this.db.collection('fines').insertMany(finesWithDates);
        console.log(` Inserite ${finesWithDates.length} multe`);
      }

      // Inserisci staff
      if (sampleData.staff && sampleData.staff.length > 0) {
        const staffWithDates = sampleData.staff.map(staff => ({
          ...staff,
          hire_date: new Date(staff.hire_date),
          'metadata.created_at': new Date(staff.metadata.created_at),
          'metadata.updated_at': new Date(staff.metadata.updated_at)
        }));

        await this.db.collection('staff').insertMany(staffWithDates);
        console.log(` Inseriti ${staffWithDates.length} membri dello staff`);
      }

      // Inserisci categorie ed eventi
      const simpleCollections = ['categories', 'events'];
      for (const collectionName of simpleCollections) {
        if (sampleData[collectionName] && sampleData[collectionName].length > 0) {
          const documentsWithDates = sampleData[collectionName].map(doc => {
            const newDoc = { ...doc };
            // Converti tutte le date trovate nell'oggetto
            Object.keys(newDoc).forEach(key => {
              if (typeof newDoc[key] === 'string' && newDoc[key].includes('T') && newDoc[key].includes('Z')) {
                newDoc[key] = new Date(newDoc[key]);
              }
              if (typeof newDoc[key] === 'object' && newDoc[key] !== null) {
                Object.keys(newDoc[key]).forEach(subKey => {
                  if (typeof newDoc[key][subKey] === 'string' && newDoc[key][subKey].includes('T') && newDoc[key][subKey].includes('Z')) {
                    newDoc[key][subKey] = new Date(newDoc[key][subKey]);
                  }
                });
              }
            });
            return newDoc;
          });

          await this.db.collection(collectionName).insertMany(documentsWithDates);
          console.log(` Inseriti ${documentsWithDates.length} documenti in '${collectionName}'`);
        }
      }

    } catch (error) {
      console.error(' Errore nel caricamento dei dati:', error.message);
      throw error;
    }
  }

  async createSampleDataFile() {
    console.log(' Creazione file dati di esempio...');
    
    // Assicurati che la directory data esista
    const dataDir = path.join(__dirname, 'data');
    try {
      await fs.access(dataDir);
    } catch {
      await fs.mkdir(dataDir, { recursive: true });
      console.log(' Directory data creata');
    }

    // Il contenuto JSON √® quello che hai gi√† definito nell'artifact precedente
    // Per semplicit√†, lo includiamo direttamente qui
    const sampleData = {
      // ... (tutto il contenuto JSON dell'artifact precedente)
      // Per brevit√† non lo ricopio tutto, ma dovrebbe essere identico
    };

    const sampleDataPath = path.join(dataDir, 'sample-data.json');
    await fs.writeFile(sampleDataPath, JSON.stringify(sampleData, null, 2));
    console.log(' File sample-data.json creato');
  }

  async validateData() {
    console.log(' Validazione dati...');

    const collections = await this.db.listCollections().toArray();
    console.log(` Collezioni create: ${collections.map(c => c.name).join(', ')}`);

    // Conta documenti per collezione
    for (const collection of collections) {
      const count = await this.db.collection(collection.name).countDocuments();
      console.log(`   ${collection.name}: ${count} documenti`);
    }

    // Test di alcune query comuni
    console.log(' Test query...');

    // Libri disponibili
    const availableBooks = await this.db.collection('books').countDocuments({
      'copies.status': 'available'
    });
    console.log(`   Libri disponibili: ${availableBooks}`);

    // Utenti attivi
    const activeUsers = await this.db.collection('users').countDocuments({
      'membership.status': 'active'
    });
    console.log(`   Utenti attivi: ${activeUsers}`);

    // Prestiti attivi
    const activeLoans = await this.db.collection('loans').countDocuments({
      'status': 'active'
    });
    console.log(`   Prestiti attivi: ${activeLoans}`);

    console.log(' Validazione completata');
  }

  async run() {
    try {
      await this.connect();
      await this.createCollections();
      await this.createIndexes();
      // Nota: decommentare la riga seguente se il file sample-data.json non esiste
      // await this.createSampleDataFile();
      await this.loadSampleData();
      await this.validateData();
      
      console.log(' Setup del database completato con successo!');
      console.log('');
      console.log(' Prossimi passi:');
      console.log('   1. Accedi a Mongo Express: http://localhost:8081');
      console.log('   2. Esplora le collezioni create');
      console.log('   3. Testa le query con MongoDB Compass');
      console.log('');
      console.log(' Comandi utili:');
      console.log('   - Connessione diretta: mongosh "mongodb://admin:password123@localhost:27017/library_db"');
      console.log('   - Backup: mongodump --uri="mongodb://admin:password123@localhost:27017/library_db"');
      
    } catch (error) {
      console.error(' Errore durante il setup:', error.message);
      process.exit(1);
    } finally {
      await this.disconnect();
    }
  }
}

// Test di connessione semplice
async function testConnection() {
  console.log(' Test di connessione...');
  const client = new MongoClient(config.url, config.options);
  
  try {
    await client.connect();
    await client.db(config.dbName).admin().ping();
    console.log(' Connessione MongoDB funzionante');
  } catch (error) {
    console.error('Connessione fallita:', error.message);
    console.log(' Assicurati che MongoDB sia in esecuzione:');
    console.log('   docker-compose up -d');
  } finally {
    await client.close();
  }
}

// Funzione per pulire il database
async function cleanDatabase() {
  console.log(' Pulizia database...');
  const client = new MongoClient(config.url, config.options);
  
  try {
    await client.connect();
    const db = client.db(config.dbName);
    
    const collections = await db.listCollections().toArray();
    for (const collection of collections) {
      await db.collection(collection.name).deleteMany({});
      console.log(`üóëÔ∏è  Collezione '${collection.name}' svuotata`);
    }
    
    console.log(' Database pulito');
  } catch (error) {
    console.error(' Errore nella pulizia:', error.message);
  } finally {
    await client.close();
  }
}

// Esecuzione dello script
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.includes('--test')) {
    testConnection();
  } else if (args.includes('--clean')) {
    cleanDatabase();
  } else {
    const setup = new LibraryDatabaseSetup();
    setup.run();
  }
}

module.exports = { LibraryDatabaseSetup, testConnection, cleanDatabase };